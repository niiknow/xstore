// Generated by CoffeeScript 1.10.0
(function(win) {
  var cacheBust, cookie, debug, delay, dnt, doc, load, log, maxStore, mydeferred, myproxy, myq, onMessage, q, randomHash, store, usePostMessage, xstore;
  doc = win.document;
  debug = require('debug');
  log = debug('xstore');
  load = require('load-iframe');
  store = require('store.js');
  cookie = require('cookie');
  usePostMessage = win.postMessage != null;
  cacheBust = 0;
  delay = 333;
  maxStore = 6000 * 60 * 24 * 777;
  myq = [];
  q = setInterval(function() {
    if (myq.length > 0) {
      return myq.shift()();
    }
  }, delay + 5);
  dnt = win.navigator.doNotTrack || win.navigator.msDoNotTrack || win.doNotTrack;
  onMessage = function(fn) {
    if (win.addEventListener) {
      return win.addEventListener("message", fn, false);
    } else {
      return win.attachEvent("onmessage", fn);
    }
  };

  /**
   * defer/promise class
   *
   */
  mydeferred = (function() {
    var i, k, len, ref, v;

    function mydeferred() {}

    mydeferred.prototype.q = function(xs, event, item) {
      var d, dh, self;
      self = this;
      self.mycallbacks = [];
      self.myerrorbacks = [];
      dh = randomHash();
      d = [0, dh, event, item.k, item.v];
      xs.dob[dh] = self;
      if (usePostMessage) {
        xs.doPostMessage(xs, JSON.stringify(d));
      } else {
        if (xs.iframe !== null) {
          cacheBust += 1;
          d[0] = +(new Date) + cacheBust;
          xs.hash = '#' + JSON.stringify(d);
          if (xs.iframe.src) {
            xs.iframe.src = "" + proxyPage + xs.hash;
          } else if ((xs.iframe.contentWindow != null) && (xs.iframe.contentWindow.location != null)) {
            xs.iframe.contentWindow.location = "" + proxyPage + xs.hash;
          } else {
            xs.iframe.setAttribute('src', "" + proxyPage + xs.hash);
          }
        }
      }
      self.then = function(fn, fnErr) {
        if (fnErr) {
          self.myerrorbacks.push(fnErr);
        }
        self.mycallbacks.push(fn);
        return self;
      };
      return self;
    };

    mydeferred.prototype.myresolve = function(data) {
      var i, k, len, ref, self, v;
      self = this;
      ref = self.mycallbacks || [];
      for (k = i = 0, len = ref.length; i < len; k = ++i) {
        v = ref[k];
        v(data);
      }
      return self;
    };

    mydeferred.prototype.myreject = function(e) {
      var self;
      return self = this;
    };

    ref = self.myerrorbacks || [];
    for (k = i = 0, len = ref.length; i < len; k = ++i) {
      v = ref[k];
      v(data);
    }

    self;

    return mydeferred;

  })();
  myproxy = (function() {
    function myproxy() {}

    myproxy.prototype.delay = 333;

    myproxy.prototype.hash = win.location.hash;

    myproxy.prototype.init = function() {
      var self;
      self = this;
      if (usePostMessage) {
        return onMessage(self.handleProxyMessage);
      } else {
        return setInterval((function() {
          var newhash;
          newhash = win.location.hash;
          if (newhash !== xs.hash) {
            xs.hash = newhash;
            self.handleProxyMessage({
              data: JSON.parse(newhash.substr(1))
            });
          }
        }), self.delay);
      }
    };

    myproxy.prototype.handleProxyMessage = function(e) {
      var d, error, hash, id, key, method, myCacheBust, mystore, self;
      d = e.data;
      if (typeof d === "string") {
        if (/^xstore-/.test(d)) {
          d = d.split(",");
        } else {
          try {
            d = JSON.parse(d);
          } catch (error) {
            return;
          }
        }
      }
      if (!(d instanceof Array)) {
        return;
      }
      id = d[1];
      if (!/^xstore-/.test(id)) {
        return;
      }
      self = this;
      key = d[3] || 'xstore';
      method = d[2];
      cacheBust = 0;
      mystore = store;
      if (!store.enabled) {
        mystore = {
          get: function(k) {
            return cookie(key);
          },
          set: function(k, v) {
            return cookie(k, v, {
              maxage: maxStore
            });
          },
          remove: function(k) {
            return cookie(k, null);
          },
          clear: function() {
            var cookies, i, idx, k, len, name, results, v;
            cookies = doc.cookie.split(';');
            results = [];
            for (k = i = 0, len = cookies.length; i < len; k = ++i) {
              v = cookies[k];
              idx = v.indexOf('=');
              name = idx > -1 ? v.substr(0, idx) : v;
              results.push(doc.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT');
            }
            return results;
          }
        };
      }
      if (method === 'get') {
        d[4] = mystore.get(key);
      } else if (method === 'set') {
        mystore.set(key, d[4]);
      } else if (method === 'remove') {
        mystore.remove(key);
      } else if (method === 'clear') {
        mystore.clear();
      } else {
        d[2] = 'error-' + method;
      }
      d[1] = id.replace('xstore-', 'xstoreproxy-');
      if (usePostMessage) {
        e.source.postMessage(JSON.stringify(d), '*');
      } else {
        cacheBust += 1;
        myCacheBust = +(new Date) + cacheBust;
        d[0] = myCacheBust;
        hash = '#' + JSON.stringify(d);
        win.location = win.location.href.replace(win.location.hash, '') + hash;
      }
    };

    return myproxy;

  })();
  randomHash = function() {
    var rh;
    rh = Math.random().toString(36).substr(2);
    return "xstore-" + rh;
  };

  /**
   * xstore class
   *
   */
  xstore = (function() {
    function xstore() {}

    xstore.prototype.hasInit = false;

    xstore.prototype.debug = debug;

    xstore.prototype.proxyPage = '//niiknow.github.io/xstore/xstore.html';

    xstore.prototype.iframe = null;

    xstore.prototype.proxyWin = null;

    xstore.prototype.hash = null;

    xstore.prototype.tempStore = {};

    xstore.prototype.dob = {};

    xstore.prototype.get = function(k) {
      this.init();
      if (dnt) {
        return {
          then: function(fn) {
            return fn(self.tempStore[k]);
          }
        };
      }
      return (new mydeferred()).q(this, 'get', {
        'k': k
      });
    };

    xstore.prototype.set = function(k, v) {
      this.init();
      if (dnt) {
        return {
          then: function(fn) {
            self.tempStore[k] = v;
            return fn(self.tempStore[k]);
          }
        };
      }
      return (new mydeferred()).q(this, 'set', {
        'k': k,
        'v': v
      });
    };

    xstore.prototype.remove = function(k) {
      this.init();
      if (dnt) {
        return {
          then: function(fn) {
            delete self.tempStore[k];
            return fn;
          }
        };
      }
      return (new mydeferred()).q(this, 'remove', {
        'k': k
      });
    };

    xstore.prototype.clear = function() {
      this.init();
      if (dnt) {
        return {
          then: function(fn) {
            self.tempStore = {};
            return fn;
          }
        };
      }
      return (new mydeferred()).q(this, 'clear');
    };

    xstore.prototype.doPostMessage = function(xs, msg) {
      if ((xs.proxyWin != null)) {
        clearInterval(q);
        xs.proxyWin.postMessage(msg, '*');
      }
      return myq.push(function() {
        return xs.doPostMessage(xs, msg);
      });
    };

    xstore.prototype.handleMessageEvent = function(e) {
      var d, di, error, id, self;
      self = this;
      d = e.data;
      if (typeof d === "string") {
        if (/^xstoreproxy-/.test(d)) {
          d = d.split(",");
        } else {
          try {
            d = JSON.parse(d);
          } catch (error) {
            return;
          }
        }
      }
      if (!(d instanceof Array)) {
        return;
      }
      id = d[1];
      if (!/^xstoreproxy-/.test(id)) {
        return;
      }
      id = id.replace('xstoreproxy-', 'xstore-');
      di = self.dob[id];
      if (di) {
        if (/^error-/.test(d[2])) {
          di.myreject(d[2]);
        } else {
          di.myresolve(d[4]);
        }
        return self.dob[id] = null;
      }
    };

    xstore.prototype.init = function(options) {
      var iframe, self;
      self = this;
      if (self.hasInit) {
        return self;
      }
      self.hasInit = true;
      options = options || {};
      if (options.isProxy) {
        log('init proxy');
        (new myproxy()).init();
        return self;
      }
      self.proxyPage = options.url || self.proxyPage;
      if (options.dntIgnore || typeof dnt === 'undefined' || dnt === 'unspecified' || dnt === 'no' || dnt === '0') {
        log("disable dnt");
        dnt = false;
      }
      log("init storeage dnt = " + dnt);
      return iframe = load(self.proxyPage, function() {
        log('iframe loaded');
        self.proxyWin = iframe.contentWindow;
        if (!usePostMessage) {
          self.hash = proxyWin.location.hash;
          return setInterval((function() {
            if (proxyWin.location.hash !== hash) {
              self.hash = proxyWin.location.hash;
              self.handleMessageEvent({
                origin: proxyDomain,
                data: self.hash.substr(1)
              });
            }
          }), delay);
        } else {
          return onMessage(function() {
            return self.handleMessageEvent(arguments[0]);
          });
        }
      });
    };

    return xstore;

  })();
  return module.exports = xstore;
})(window);
